<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>BW4SA: src/utils/wavelet_tree.c File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">BW4SA
   &#160;<span id="projectnumber">0.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('wavelet__tree_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">wavelet_tree.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of the wavelet tree-structure.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="wavelet__tree_8h_source.html">wavelet_tree.h</a>&quot;</code><br/>
<code>#include &quot;utils.h&quot;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;math.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;limits.h&gt;</code><br/>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wavelet__tree_8c.html#aab891a986c4ad3780026826914845a47">wavelet_rank_query</a> (const <a class="el" href="structwavelet__tree.html">wavelet_tree</a> *tree, unsigned int curr_node, char c, int start, int end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation for the rank query on a wavelet tree.  <a href="#aab891a986c4ad3780026826914845a47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wavelet__tree_8c.html#ad7e6dab5c062a8d3c866a5e07ba0a869">wavelet_root_rank_query</a> (const <a class="el" href="structwavelet__tree.html">wavelet_tree</a> *tree, char c, int start, int end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The rank query that is called from inside the tree.  <a href="#ad7e6dab5c062a8d3c866a5e07ba0a869"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wavelet__tree_8c.html#a329b033033877b868846dc0df7962cbc">wavelet_char_at</a> (const <a class="el" href="structwavelet__tree.html">wavelet_tree</a> *tree, unsigned int curr_node, int index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the character at a certain index inside a wavelet tree.  <a href="#a329b033033877b868846dc0df7962cbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wavelet__tree_8c.html#ab3bb865cd8b539e8aeed14f3a67538de">wavelet_root_char_at</a> (const <a class="el" href="structwavelet__tree.html">wavelet_tree</a> *tree, int index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The root function of char at that is called from the tree.  <a href="#ab3bb865cd8b539e8aeed14f3a67538de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wavelet__tree_8c.html#a2d8f3e208f10049bb10d79f55f5db4c1">get_num_bits_tree</a> (const <a class="el" href="structwavelet__tree.html">wavelet_tree</a> *tree)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that returns the number of bits inside the bit vector of the root node (= length of the string).  <a href="#a2d8f3e208f10049bb10d79f55f5db4c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wavelet__tree_8c.html#a33636ffed94167f0292acc353f547939">get_alphabet_length_tree</a> (const <a class="el" href="structwavelet__tree.html">wavelet_tree</a> *tree)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that returns the length of the alphabet of the root node.  <a href="#a33636ffed94167f0292acc353f547939"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wavelet__tree_8c.html#afe01ea4817367e22c71c6fb6075a6a56">get_alphabet_tree</a> (const <a class="el" href="structwavelet__tree.html">wavelet_tree</a> *tree)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that returns the alphabet of the root node.  <a href="#afe01ea4817367e22c71c6fb6075a6a56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="wavelet__tree_8h.html#structwavelet__node">wavelet_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wavelet__tree_8c.html#a9bb056fc8c074f02fd662f11ca456ef3">init_node</a> (<a class="el" href="wavelet__tree_8h.html#structwavelet__node">wavelet_node</a> *node, const char *string, const char *alphabet, unsigned int alphabet_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple function for initializing the values in a wavelet node.  <a href="#a9bb056fc8c074f02fd662f11ca456ef3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbit__vector.html">bit_vector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wavelet__tree_8c.html#ae09798b7104916d8431d0682367dbd35">create_bit_vector</a> (<a class="el" href="structbit__vector.html">bit_vector</a> *vector, const char *string, const char *alphabet, unsigned int alphabet_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a bit vector based on the alphabet of the node.  <a href="#ae09798b7104916d8431d0682367dbd35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wavelet__tree_8c.html#a2bce515c362e564783e01ea820b3dc1b">determine_substrings</a> (const <a class="el" href="structwavelet__tree.html">wavelet_tree</a> *tree, unsigned int parent, char **string_arr, const char *string)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string into two substrings.  <a href="#a2bce515c362e564783e01ea820b3dc1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wavelet__tree_8c.html#aec478356e996a94896f0ddb7d61927ce">create_children</a> (<a class="el" href="structwavelet__tree.html">wavelet_tree</a> *tree, unsigned int curr_node, unsigned int next, const char *string)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively creates children for a node.  <a href="#aec478356e996a94896f0ddb7d61927ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structwavelet__tree.html">wavelet_tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wavelet__tree_8c.html#aab889ddd1b3f199d71afbe5b5b6a11ee">create_wavelet_tree</a> (const char *string)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An algorithm that creates a wavelet tree from a string.  <a href="#aab889ddd1b3f199d71afbe5b5b6a11ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wavelet__tree_8c.html#ae16c72d54d8732a777355b8b16056cc1">free_subtree</a> (<a class="el" href="structwavelet__tree.html">wavelet_tree</a> *tree, unsigned int node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a wavelet (sub)tree.  <a href="#ae16c72d54d8732a777355b8b16056cc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wavelet__tree_8c.html#a9c13c241eb5cc6cd13afda56b1d77713">free_wavelet_tree_internals</a> (<a class="el" href="structwavelet__tree.html">wavelet_tree</a> *tree)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A function for freeing the internal variables used by a wavelet tree without freeing the tree itself.  <a href="#a9c13c241eb5cc6cd13afda56b1d77713"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wavelet__tree_8c.html#a5f51f4862a9d800d517cc03b6423bb9f">free_wavelet_tree</a> (<a class="el" href="structwavelet__tree.html">wavelet_tree</a> *tree)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by an entire wavelet tree.  <a href="#a5f51f4862a9d800d517cc03b6423bb9f"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Implementation of the wavelet tree-structure. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Max Sandberg (REXiator) </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000139">Bug:</a></b></dt><dd>No known bugs. </dd></dl>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae09798b7104916d8431d0682367dbd35"></a><!-- doxytag: member="wavelet_tree.c::create_bit_vector" ref="ae09798b7104916d8431d0682367dbd35" args="(bit_vector *vector, const char *string, const char *alphabet, unsigned int alphabet_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbit__vector.html">bit_vector</a>* <a class="el" href="wavelet__tree_8c.html#ae09798b7104916d8431d0682367dbd35">create_bit_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbit__vector.html">bit_vector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>alphabet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>alphabet_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a bit vector based on the alphabet of the node. </p>
<p>This algorithm creates a bit vector with every character in the alphabet of the node marked as a 1 inside the bit vector and all other characters marked as 0.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>The bit vector that is to be initialized. </td></tr>
    <tr><td class="paramname">string</td><td>The string for which a bit vector is created. </td></tr>
    <tr><td class="paramname">alphabet</td><td>The alphabet used by the string. </td></tr>
    <tr><td class="paramname">alphabet_length</td><td>The length of the alphabet used by the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns an initialized bit vector based on the string and alphabet supplied as parameters, or NULL if either string is uninitialized or the vector couldn't be initialized. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bit__vector_8h.html" title="An array structure for storing strings compressed into integers.">bit_vector.h</a> </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Max Sandberg (REXiator) </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000148">Bug:</a></b></dt><dd>No known bugs. </dd></dl>

<p>References <a class="el" href="utils_8c.html#a448fa999eada43a374620e2d8bf8d990">binary_search()</a>, <a class="el" href="bit__vector_8c.html#a586a9d4e8a08b59193ec8f29ef8f16aa">init_bit_vector()</a>, and <a class="el" href="structbit__vector.html#afa480cad95d28f925a48ef49a26f83d8">bit_vector::mark_bit</a>.</p>

<p>Referenced by <a class="el" href="wavelet__tree_8c.html#aec478356e996a94896f0ddb7d61927ce">create_children()</a>.</p>

</div>
</div>
<a class="anchor" id="aec478356e996a94896f0ddb7d61927ce"></a><!-- doxytag: member="wavelet_tree.c::create_children" ref="aec478356e996a94896f0ddb7d61927ce" args="(wavelet_tree *tree, unsigned int curr_node, unsigned int next, const char *string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="wavelet__tree_8c.html#aec478356e996a94896f0ddb7d61927ce">create_children</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwavelet__tree.html">wavelet_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>curr_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recursively creates children for a node. </p>
<p>This algorithm populates the wavelet tree. It takes an initialized node as parameter for which it creates a bit vector and any possible children. If children are created, it will recursively call itself for the children. Otherwise it will return the index where the next node should be placed inside the tree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The wavelet tree that is being populated. </td></tr>
    <tr><td class="paramname">curr_node</td><td>The index of the node for which a bit vector and children is to be created. </td></tr>
    <tr><td class="paramname">next</td><td>Index of the next free space inside the wavelet tree. </td></tr>
    <tr><td class="paramname">string</td><td>The substring used by the current node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next free index inside the wavelet tree. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Max Sandberg (REXiator) </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000150">Bug:</a></b></dt><dd>No known bugs. </dd></dl>

<p>References <a class="el" href="wavelet__tree_8c.html#ae09798b7104916d8431d0682367dbd35">create_bit_vector()</a>, <a class="el" href="wavelet__tree_8c.html#a2bce515c362e564783e01ea820b3dc1b">determine_substrings()</a>, and <a class="el" href="wavelet__tree_8c.html#a9bb056fc8c074f02fd662f11ca456ef3">init_node()</a>.</p>

<p>Referenced by <a class="el" href="wavelet__tree_8h.html#aab889ddd1b3f199d71afbe5b5b6a11ee">create_wavelet_tree()</a>.</p>

</div>
</div>
<a class="anchor" id="aab889ddd1b3f199d71afbe5b5b6a11ee"></a><!-- doxytag: member="wavelet_tree.c::create_wavelet_tree" ref="aab889ddd1b3f199d71afbe5b5b6a11ee" args="(const char *string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwavelet__tree.html">wavelet_tree</a>* <a class="el" href="wavelet__tree_8h.html#aab889ddd1b3f199d71afbe5b5b6a11ee">create_wavelet_tree</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An algorithm that creates a wavelet tree from a string. </p>
<p>This algorithm recursively creates a wavelet tree from the string supplied as parameter.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string of characters from which a wavelet tree is to be constructed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A structure containing the wavelet tree, or NULL if the string is uninitialized. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Max Sandberg (REXiator) </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000155">Bug:</a></b></dt><dd>No known bugs. </dd></dl>

<p>References <a class="el" href="structwavelet__tree.html#a96869ef02d34b2f00e2eeec474bd79f8">wavelet_tree::char_at</a>, <a class="el" href="wavelet__tree_8c.html#aec478356e996a94896f0ddb7d61927ce">create_children()</a>, <a class="el" href="utils_8c.html#ad73b9e1214ba189b383a04fa6b964028">determine_alphabet()</a>, <a class="el" href="structwavelet__tree.html#a739eef1c9eb98267d0fdc75ba05d99b7">wavelet_tree::get_alphabet</a>, <a class="el" href="structwavelet__tree.html#a1905ffea2dc3815d49561237b4f8488a">wavelet_tree::get_alphabet_length</a>, <a class="el" href="wavelet__tree_8c.html#a33636ffed94167f0292acc353f547939">get_alphabet_length_tree()</a>, <a class="el" href="wavelet__tree_8c.html#afe01ea4817367e22c71c6fb6075a6a56">get_alphabet_tree()</a>, <a class="el" href="structwavelet__tree.html#aa66e703dce8676f909c1a461c40b5abf">wavelet_tree::get_num_bits</a>, <a class="el" href="wavelet__tree_8c.html#a2d8f3e208f10049bb10d79f55f5db4c1">get_num_bits_tree()</a>, <a class="el" href="wavelet__tree_8c.html#a9bb056fc8c074f02fd662f11ca456ef3">init_node()</a>, <a class="el" href="utils_8c.html#a4b344a67ac94d676c163c0bce050a4d7">quick_sort()</a>, <a class="el" href="structwavelet__tree.html#ad578b3f750505527bcb0e9778cb26030">wavelet_tree::rank</a>, <a class="el" href="wavelet__tree_8c.html#ab3bb865cd8b539e8aeed14f3a67538de">wavelet_root_char_at()</a>, and <a class="el" href="wavelet__tree_8c.html#ad7e6dab5c062a8d3c866a5e07ba0a869">wavelet_root_rank_query()</a>.</p>

<p>Referenced by <a class="el" href="s__to__bwt_8h.html#aa89b0d8459eea0a51c3d5eb1d73f9649">s_to_bwt()</a>.</p>

</div>
</div>
<a class="anchor" id="a2bce515c362e564783e01ea820b3dc1b"></a><!-- doxytag: member="wavelet_tree.c::determine_substrings" ref="a2bce515c362e564783e01ea820b3dc1b" args="(const wavelet_tree *tree, unsigned int parent, char **string_arr, const char *string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** <a class="el" href="wavelet__tree_8c.html#a2bce515c362e564783e01ea820b3dc1b">determine_substrings</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwavelet__tree.html">wavelet_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>string_arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Splits a string into two substrings. </p>
<p>This algorithm splits a string into two substrings by taking all the 0-marked characters in the bit vector of the parent and putting them in one string and the 1-marked characters into another string.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The wavelet tree where the parent node resides. </td></tr>
    <tr><td class="paramname">parent</td><td>The index of the parent node inside the wavelet tree from which a new set of substrings should be determined. </td></tr>
    <tr><td class="paramname">string_arr</td><td>An array of strings with space for 2 strings. </td></tr>
    <tr><td class="paramname">string</td><td>The string that is to be split. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An array of the two constructed substrings. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Max Sandberg (REXiator) </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000149">Bug:</a></b></dt><dd>No known bugs. </dd></dl>

<p>References <a class="el" href="structbit__vector.html#a4dd635a7181b451d8a708d152202a9f9">bit_vector::get_length</a>, <a class="el" href="structbit__vector.html#ad8ffb52bc86612775cdca0d9d02dbf1a">bit_vector::is_bit_marked</a>, and <a class="el" href="structbit__vector.html#a0cb7e47ff1bfefaf8e2cc0d5b4a361c3">bit_vector::rank</a>.</p>

<p>Referenced by <a class="el" href="wavelet__tree_8c.html#aec478356e996a94896f0ddb7d61927ce">create_children()</a>.</p>

</div>
</div>
<a class="anchor" id="ae16c72d54d8732a777355b8b16056cc1"></a><!-- doxytag: member="wavelet_tree.c::free_subtree" ref="ae16c72d54d8732a777355b8b16056cc1" args="(wavelet_tree *tree, unsigned int node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="wavelet__tree_8c.html#ae16c72d54d8732a777355b8b16056cc1">free_subtree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwavelet__tree.html">wavelet_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees a wavelet (sub)tree. </p>
<p>This algorithm frees a wavelet node and all of it's descendants. It does not free the alphabet used by the wavelet tree but it does break the link between the parent node and the subtree that is being freed, so it should be used with caution.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The wavelet tree where the subtree resides. </td></tr>
    <tr><td class="paramname">node</td><td>The index of the root of the subtree that is to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="wavelet__tree_8h.html#a5f51f4862a9d800d517cc03b6423bb9f" title="Frees the memory used by an entire wavelet tree.">free_wavelet_tree</a> </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Max Sandberg (REXiator) </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000151">Bug:</a></b></dt><dd>No known bugs. </dd></dl>

<p>Referenced by <a class="el" href="wavelet__tree_8h.html#a9c13c241eb5cc6cd13afda56b1d77713">free_wavelet_tree_internals()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f51f4862a9d800d517cc03b6423bb9f"></a><!-- doxytag: member="wavelet_tree.c::free_wavelet_tree" ref="a5f51f4862a9d800d517cc03b6423bb9f" args="(wavelet_tree *tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="wavelet__tree_8h.html#a5f51f4862a9d800d517cc03b6423bb9f">free_wavelet_tree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwavelet__tree.html">wavelet_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees the memory used by an entire wavelet tree. </p>
<p>This algorithm frees an entire wavelet tree. It also frees the alphabet used by the wavelet tree, but leaves the original string from which the tree was created intact.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The wavelet tree to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Max Sandberg (REXiator) </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000157">Bug:</a></b></dt><dd>No known bugs. </dd></dl>

<p>References <a class="el" href="wavelet__tree_8c.html#a9c13c241eb5cc6cd13afda56b1d77713">free_wavelet_tree_internals()</a>.</p>

<p>Referenced by <a class="el" href="draw__tree_8h.html#ad7157b2c81e9f0c8a0af5a8c5d65303c">draw_suffix_tree()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c13c241eb5cc6cd13afda56b1d77713"></a><!-- doxytag: member="wavelet_tree.c::free_wavelet_tree_internals" ref="a9c13c241eb5cc6cd13afda56b1d77713" args="(wavelet_tree *tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="wavelet__tree_8h.html#a9c13c241eb5cc6cd13afda56b1d77713">free_wavelet_tree_internals</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwavelet__tree.html">wavelet_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A function for freeing the internal variables used by a wavelet tree without freeing the tree itself. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree whose internals should be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Max Sandberg (REXiator) </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000156">Bug:</a></b></dt><dd>No known bugs. </dd></dl>

<p>References <a class="el" href="wavelet__tree_8c.html#ae16c72d54d8732a777355b8b16056cc1">free_subtree()</a>.</p>

<p>Referenced by <a class="el" href="iterate_8h.html#a0bf99401563663d6262e19f10c1b14de">free_iterator_state()</a>, and <a class="el" href="wavelet__tree_8h.html#a5f51f4862a9d800d517cc03b6423bb9f">free_wavelet_tree()</a>.</p>

</div>
</div>
<a class="anchor" id="a33636ffed94167f0292acc353f547939"></a><!-- doxytag: member="wavelet_tree.c::get_alphabet_length_tree" ref="a33636ffed94167f0292acc353f547939" args="(const wavelet_tree *tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="wavelet__tree_8c.html#a33636ffed94167f0292acc353f547939">get_alphabet_length_tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwavelet__tree.html">wavelet_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A function that returns the length of the alphabet of the root node. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree for which the alphabet length should be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The length of the longest alphabet in the tree. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Max Sandberg (REXiator) </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000145">Bug:</a></b></dt><dd>No known bugs. </dd></dl>

<p>Referenced by <a class="el" href="wavelet__tree_8h.html#aab889ddd1b3f199d71afbe5b5b6a11ee">create_wavelet_tree()</a>.</p>

</div>
</div>
<a class="anchor" id="afe01ea4817367e22c71c6fb6075a6a56"></a><!-- doxytag: member="wavelet_tree.c::get_alphabet_tree" ref="afe01ea4817367e22c71c6fb6075a6a56" args="(const wavelet_tree *tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* <a class="el" href="wavelet__tree_8c.html#afe01ea4817367e22c71c6fb6075a6a56">get_alphabet_tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwavelet__tree.html">wavelet_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A function that returns the alphabet of the root node. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree for which the alphabet should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The alphabet used by the root node. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Max Sandberg (REXiator) </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000146">Bug:</a></b></dt><dd>No known bugs. </dd></dl>

<p>Referenced by <a class="el" href="wavelet__tree_8h.html#aab889ddd1b3f199d71afbe5b5b6a11ee">create_wavelet_tree()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d8f3e208f10049bb10d79f55f5db4c1"></a><!-- doxytag: member="wavelet_tree.c::get_num_bits_tree" ref="a2d8f3e208f10049bb10d79f55f5db4c1" args="(const wavelet_tree *tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="wavelet__tree_8c.html#a2d8f3e208f10049bb10d79f55f5db4c1">get_num_bits_tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwavelet__tree.html">wavelet_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A function that returns the number of bits inside the bit vector of the root node (= length of the string). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The wavelet tree for which the length of the root string is to be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The length of the string used by the root node. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Max Sandberg (REXiator) </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000144">Bug:</a></b></dt><dd>No known bugs. </dd></dl>

<p>References <a class="el" href="structbit__vector.html#a4dd635a7181b451d8a708d152202a9f9">bit_vector::get_length</a>.</p>

<p>Referenced by <a class="el" href="wavelet__tree_8h.html#aab889ddd1b3f199d71afbe5b5b6a11ee">create_wavelet_tree()</a>.</p>

</div>
</div>
<a class="anchor" id="a9bb056fc8c074f02fd662f11ca456ef3"></a><!-- doxytag: member="wavelet_tree.c::init_node" ref="a9bb056fc8c074f02fd662f11ca456ef3" args="(wavelet_node *node, const char *string, const char *alphabet, unsigned int alphabet_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="wavelet__tree_8h.html#structwavelet__node">wavelet_node</a>* <a class="el" href="wavelet__tree_8c.html#a9bb056fc8c074f02fd662f11ca456ef3">init_node</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="wavelet__tree_8h.html#structwavelet__node">wavelet_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>alphabet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>alphabet_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A simple function for initializing the values in a wavelet node. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node that is to be initialized. </td></tr>
    <tr><td class="paramname">string</td><td>The string used by the node. </td></tr>
    <tr><td class="paramname">alphabet</td><td>Half of the alphabet used by the string of the node. </td></tr>
    <tr><td class="paramname">alphabet_length</td><td>Length of the alphabet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An initialized wavelet node. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Max Sandberg (REXiator) </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000147">Bug:</a></b></dt><dd>No known bugs. </dd></dl>

<p>Referenced by <a class="el" href="wavelet__tree_8c.html#aec478356e996a94896f0ddb7d61927ce">create_children()</a>, and <a class="el" href="wavelet__tree_8h.html#aab889ddd1b3f199d71afbe5b5b6a11ee">create_wavelet_tree()</a>.</p>

</div>
</div>
<a class="anchor" id="a329b033033877b868846dc0df7962cbc"></a><!-- doxytag: member="wavelet_tree.c::wavelet_char_at" ref="a329b033033877b868846dc0df7962cbc" args="(const wavelet_tree *tree, unsigned int curr_node, int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="wavelet__tree_8c.html#a329b033033877b868846dc0df7962cbc">wavelet_char_at</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwavelet__tree.html">wavelet_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>curr_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the character at a certain index inside a wavelet tree. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree that is to be searched. </td></tr>
    <tr><td class="paramname">curr_node</td><td>The current node that is under search. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the character that is to be identified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The found character at the location. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Max Sandberg (REXiator) </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000142">Bug:</a></b></dt><dd>No known bugs. </dd></dl>

<p>References <a class="el" href="structbit__vector.html#ad8ffb52bc86612775cdca0d9d02dbf1a">bit_vector::is_bit_marked</a>, and <a class="el" href="structbit__vector.html#a0cb7e47ff1bfefaf8e2cc0d5b4a361c3">bit_vector::rank</a>.</p>

<p>Referenced by <a class="el" href="wavelet__tree_8c.html#ab3bb865cd8b539e8aeed14f3a67538de">wavelet_root_char_at()</a>.</p>

</div>
</div>
<a class="anchor" id="aab891a986c4ad3780026826914845a47"></a><!-- doxytag: member="wavelet_tree.c::wavelet_rank_query" ref="aab891a986c4ad3780026826914845a47" args="(const wavelet_tree *tree, unsigned int curr_node, char c, int start, int end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="wavelet__tree_8c.html#aab891a986c4ad3780026826914845a47">wavelet_rank_query</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwavelet__tree.html">wavelet_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>curr_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The implementation for the rank query on a wavelet tree. </p>
<p>The rank query on a wavelet tree works by recursively doing a rank function on a child of the current node based on if the character has been encoded as a 0 or a 1 in the current node. If <code>end</code> is larger than the size of the bit vector, the rank operation will be done for the entire length of the vector.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The wavelet tree on which the rank query is performed. </td></tr>
    <tr><td class="paramname">curr_node</td><td>The node on which the rank query is currently operating on. </td></tr>
    <tr><td class="paramname">c</td><td>The character for which the rank is to be found. </td></tr>
    <tr><td class="paramname">start</td><td>The indec of the first character from which the rank query should start. </td></tr>
    <tr><td class="paramname">end</td><td>The index up to which the rank query is going to be made inside the bit vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of occurrences of character <code>c</code> in a string. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="wavelet__tree_8c.html#ad7e6dab5c062a8d3c866a5e07ba0a869" title="The rank query that is called from inside the tree.">wavelet_root_rank_query</a> </dd>
<dd>
bit_vector.c::rank_query </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Max Sandberg (REXiator) </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000140">Bug:</a></b></dt><dd>No known bugs. </dd></dl>

<p>References <a class="el" href="utils_8c.html#a448fa999eada43a374620e2d8bf8d990">binary_search()</a>, and <a class="el" href="structbit__vector.html#a0cb7e47ff1bfefaf8e2cc0d5b4a361c3">bit_vector::rank</a>.</p>

<p>Referenced by <a class="el" href="wavelet__tree_8c.html#ad7e6dab5c062a8d3c866a5e07ba0a869">wavelet_root_rank_query()</a>.</p>

</div>
</div>
<a class="anchor" id="ab3bb865cd8b539e8aeed14f3a67538de"></a><!-- doxytag: member="wavelet_tree.c::wavelet_root_char_at" ref="ab3bb865cd8b539e8aeed14f3a67538de" args="(const wavelet_tree *tree, int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="wavelet__tree_8c.html#ab3bb865cd8b539e8aeed14f3a67538de">wavelet_root_char_at</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwavelet__tree.html">wavelet_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The root function of char at that is called from the tree. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree that is to be searched. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the character that is to be recognized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The found character. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="wavelet__tree_8c.html#a329b033033877b868846dc0df7962cbc" title="Returns the character at a certain index inside a wavelet tree.">wavelet_char_at</a> </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Max Sandberg (REXiator) </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000143">Bug:</a></b></dt><dd>No known bugs. </dd></dl>

<p>References <a class="el" href="structwavelet__tree.html#aa66e703dce8676f909c1a461c40b5abf">wavelet_tree::get_num_bits</a>, and <a class="el" href="wavelet__tree_8c.html#a329b033033877b868846dc0df7962cbc">wavelet_char_at()</a>.</p>

<p>Referenced by <a class="el" href="wavelet__tree_8h.html#aab889ddd1b3f199d71afbe5b5b6a11ee">create_wavelet_tree()</a>.</p>

</div>
</div>
<a class="anchor" id="ad7e6dab5c062a8d3c866a5e07ba0a869"></a><!-- doxytag: member="wavelet_tree.c::wavelet_root_rank_query" ref="ad7e6dab5c062a8d3c866a5e07ba0a869" args="(const wavelet_tree *tree, char c, int start, int end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="wavelet__tree_8c.html#ad7e6dab5c062a8d3c866a5e07ba0a869">wavelet_root_rank_query</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwavelet__tree.html">wavelet_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The rank query that is called from inside the tree. </p>
<p>The entry point for the rank query. Checks all parameters are within bounds and does an initial search for the character inside the root alphabet. If not found, 0 can be returned right away.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The wavelet tree upon which a rank query is to be made. </td></tr>
    <tr><td class="paramname">c</td><td>The character that is to be counted. </td></tr>
    <tr><td class="paramname">start</td><td>The starting index for the rank query. </td></tr>
    <tr><td class="paramname">end</td><td>The ending index for the rank query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of occurrences of character <code>c</code> between <code>start</code> and <code>end</code>. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="wavelet__tree_8c.html#aab891a986c4ad3780026826914845a47" title="The implementation for the rank query on a wavelet tree.">wavelet_rank_query</a> </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Max Sandberg (REXiator) </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000141">Bug:</a></b></dt><dd>No known bugs. </dd></dl>

<p>References <a class="el" href="utils_8c.html#a448fa999eada43a374620e2d8bf8d990">binary_search()</a>, <a class="el" href="structwavelet__tree.html#aa66e703dce8676f909c1a461c40b5abf">wavelet_tree::get_num_bits</a>, and <a class="el" href="wavelet__tree_8c.html#aab891a986c4ad3780026826914845a47">wavelet_rank_query()</a>.</p>

<p>Referenced by <a class="el" href="wavelet__tree_8h.html#aab889ddd1b3f199d71afbe5b5b6a11ee">create_wavelet_tree()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="wavelet__tree_8c.html">wavelet_tree.c</a>      </li>

    <li class="footer">Generated on Tue Apr 29 2014 20:58:09 for BW4SA by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
